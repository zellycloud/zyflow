# Go-specific Quality Rules

id: unchecked-error
language: go
severity: error
message: "Error is being ignored. Handle or explicitly ignore with comment."
rule:
  pattern: $RESULT, _ := $FUNC($$$ARGS)

---
id: error-without-wrap
language: go
severity: warning
message: "Consider wrapping error with context using fmt.Errorf or errors.Wrap"
rule:
  pattern: return $ERR
  inside:
    pattern: |
      if $ERR != nil {
          $$$BODY
      }

---
id: defer-in-loop
language: go
severity: warning
message: "defer inside loop may cause resource leak. Consider moving outside."
rule:
  pattern: defer $FUNC($$$ARGS)
  inside:
    any:
      - pattern: for $$$INIT; $$$COND; $$$POST { $$$BODY }
      - pattern: for $$$RANGE { $$$BODY }

---
id: context-first-param
language: go
severity: warning
message: "Context should be the first parameter by convention"
rule:
  pattern: func $NAME($$$BEFORE, ctx context.Context, $$$AFTER)

---
id: mutex-not-deferred
language: go
severity: warning
message: "Consider using defer for Unlock() to prevent deadlocks"
rule:
  pattern: $MU.Lock()
  not:
    follows:
      pattern: defer $MU.Unlock()

---
id: empty-interface
language: go
severity: info
message: "Consider using 'any' instead of 'interface{}' (Go 1.18+)"
rule:
  pattern: interface{}

---
id: time-now-sub
language: go
severity: info
message: "Use time.Since() instead of time.Now().Sub()"
rule:
  pattern: time.Now().Sub($TIME)
fix: time.Since($TIME)

---
id: bytes-compare
language: go
severity: info
message: "Use bytes.Equal() for comparing byte slices"
rule:
  any:
    - pattern: bytes.Compare($A, $B) == 0
    - pattern: bytes.Compare($A, $B) != 0
fix: bytes.Equal($A, $B)

---
id: string-bytes-conversion
language: go
severity: info
message: "Unnecessary string/[]byte conversion may impact performance"
rule:
  any:
    - pattern: string([]byte($STR))
    - pattern: "[]byte(string($BYTES))"

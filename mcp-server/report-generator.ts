/**
 * Report Generator
 *
 * Post-Task ì‹¤í–‰ ê²°ê³¼ë¥¼ JSON ë° Markdown ë¦¬í¬íŠ¸ë¡œ ìƒì„±
 */

import { join } from 'path';
import { mkdir, writeFile, readFile, readdir } from 'fs/promises';
import type {
  PostTaskResult,
  TaskResult,
  ReportFormat,
  ReportMetadata,
  TriggerType,
  TaskType,
} from './post-task-types.js';

/**
 * ë¦¬í¬íŠ¸ ë””ë ‰í† ë¦¬ ê²½ë¡œ
 */
const REPORTS_DIR = '.zyflow/reports/post-task';

/**
 * ë¦¬í¬íŠ¸ íŒŒì¼ëª… ìƒì„±
 */
function generateReportFilename(
  taskType: TaskType | 'all',
  format: ReportFormat
): string {
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
  return `${timestamp}_${taskType}.${format === 'json' ? 'json' : 'md'}`;
}

/**
 * JSON ë¦¬í¬íŠ¸ ìƒì„±
 */
function generateJSONReport(result: PostTaskResult): string {
  return JSON.stringify(result, null, 2);
}

/**
 * Markdown ë¦¬í¬íŠ¸ ìƒì„±
 */
function generateMarkdownReport(result: PostTaskResult): string {
  const lines: string[] = [];

  // í—¤ë”
  lines.push(`# Post-Task Report`);
  lines.push('');
  lines.push(`**Run ID:** \`${result.runId}\``);
  lines.push(`**Started:** ${result.startedAt}`);
  lines.push(`**Finished:** ${result.finishedAt}`);
  lines.push(`**Duration:** ${formatDuration(result.totalDuration)}`);
  lines.push('');

  // ìš”ì•½
  lines.push('## Summary');
  lines.push('');
  lines.push(`| Metric | Value |`);
  lines.push(`|--------|-------|`);
  lines.push(`| Total Tasks | ${result.tasksRun} |`);
  lines.push(`| Succeeded | ${result.tasksSucceeded} |`);
  lines.push(`| Failed | ${result.tasksFailed} |`);
  lines.push(`| Success Rate | ${Math.round((result.tasksSucceeded / result.tasksRun) * 100)}% |`);
  lines.push('');

  // ì „ì²´ ê²°ê³¼
  lines.push('## Results');
  lines.push('');

  for (const task of result.results) {
    const statusIcon = task.success ? 'âœ…' : 'âŒ';
    lines.push(`### ${statusIcon} ${task.task}`);
    lines.push('');
    lines.push(`- **Status:** ${task.success ? 'Success' : 'Failed'}`);
    lines.push(`- **Duration:** ${formatDuration(task.duration)}`);
    lines.push(`- **Issues Found:** ${task.issuesFound}`);
    lines.push(`- **Issues Fixed:** ${task.issuesFixed}`);
    lines.push(`- **Model:** ${task.model}`);
    lines.push(`- **CLI:** ${task.cli}`);

    if (task.error) {
      lines.push('');
      lines.push('**Error:**');
      lines.push('```');
      lines.push(task.error);
      lines.push('```');
    }

    // ì œì•ˆ
    if (task.details?.suggestions && task.details.suggestions.length > 0) {
      lines.push('');
      lines.push('**Suggestions:**');
      lines.push('');

      for (const suggestion of task.details.suggestions.slice(0, 10)) {
        const confidenceIcon =
          suggestion.confidence === 'high'
            ? 'ğŸ”´'
            : suggestion.confidence === 'medium'
              ? 'ğŸŸ¡'
              : 'ğŸŸ¢';
        lines.push(
          `- ${confidenceIcon} **${suggestion.file}**${suggestion.line ? `:${suggestion.line}` : ''}`
        );
        lines.push(`  - Issue: ${suggestion.issue}`);
        lines.push(`  - Suggestion: ${suggestion.suggestion}`);
      }

      if (task.details.suggestions.length > 10) {
        lines.push(`- ... and ${task.details.suggestions.length - 10} more`);
      }
    }

    // ìˆ˜ì •ëœ íŒŒì¼
    if (task.details?.modifiedFiles && task.details.modifiedFiles.length > 0) {
      lines.push('');
      lines.push('**Modified Files:**');
      for (const file of task.details.modifiedFiles) {
        lines.push(`- \`${file}\``);
      }
    }

    // ìƒì„±ëœ íŒŒì¼
    if (task.details?.generatedFiles && task.details.generatedFiles.length > 0) {
      lines.push('');
      lines.push('**Generated Files:**');
      for (const file of task.details.generatedFiles) {
        lines.push(`- \`${file}\``);
      }
    }

    // ê²©ë¦¬ëœ íŒŒì¼
    if (task.details?.quarantinedFiles && task.details.quarantinedFiles.length > 0) {
      lines.push('');
      lines.push('**Quarantined Files:**');
      for (const file of task.details.quarantinedFiles) {
        lines.push(`- \`${file}\``);
      }
    }

    lines.push('');
  }

  // í‘¸í„°
  lines.push('---');
  lines.push('');
  lines.push(`*Generated by ZyFlow Post-Task Agent*`);

  return lines.join('\n');
}

/**
 * ì‹œê°„ í¬ë§·íŒ…
 */
function formatDuration(ms: number): string {
  if (ms < 1000) return `${ms}ms`;
  if (ms < 60000) return `${(ms / 1000).toFixed(2)}s`;
  return `${(ms / 60000).toFixed(2)}m`;
}

/**
 * ë¦¬í¬íŠ¸ ì €ì¥
 */
export async function saveReport(
  projectPath: string,
  result: PostTaskResult,
  format: ReportFormat = 'markdown',
  triggerType: TriggerType = 'manual'
): Promise<{ success: boolean; path: string }> {
  const reportsDir = join(projectPath, REPORTS_DIR);

  try {
    // ë””ë ‰í† ë¦¬ ìƒì„±
    await mkdir(reportsDir, { recursive: true });

    // ì‘ì—… íƒ€ì… ê²°ì •
    const taskTypes = result.results.map((r) => r.task);
    const taskType = taskTypes.length === 1 ? taskTypes[0] : 'all';

    // íŒŒì¼ëª… ìƒì„±
    const filename = generateReportFilename(taskType, format);
    const filepath = join(reportsDir, filename);

    // ë¦¬í¬íŠ¸ ìƒì„±
    const content =
      format === 'json'
        ? generateJSONReport(result)
        : generateMarkdownReport(result);

    // ì €ì¥
    await writeFile(filepath, content, 'utf-8');

    return {
      success: true,
      path: filepath.replace(projectPath + '/', ''),
    };
  } catch (error) {
    console.error('Failed to save report:', error);
    return {
      success: false,
      path: '',
    };
  }
}

/**
 * ë¦¬í¬íŠ¸ ëª©ë¡ ì¡°íšŒ
 */
export async function listReports(
  projectPath: string,
  options?: { limit?: number; taskType?: TaskType }
): Promise<ReportMetadata[]> {
  const reportsDir = join(projectPath, REPORTS_DIR);
  const reports: ReportMetadata[] = [];

  try {
    const files = await readdir(reportsDir);

    for (const file of files) {
      // íŒŒì¼ëª… íŒŒì‹±: 2024-12-13T10-30-00_lint-fix.json
      const match = file.match(/^(\d{4}-\d{2}-\d{2}T\d{2}-\d{2}-\d{2})_([^.]+)\.(json|md)$/);

      if (match) {
        const timestamp = match[1].replace(/-/g, ':').replace('T', 'T');
        const taskType = match[2] as TaskType | 'all';
        const format = match[3] as ReportFormat;

        // í•„í„°ë§
        if (options?.taskType && taskType !== options.taskType && taskType !== 'all') {
          continue;
        }

        reports.push({
          id: file.replace(/\.(json|md)$/, ''),
          createdAt: timestamp,
          taskType,
          triggerType: 'manual', // íŒŒì¼ì—ì„œ ì¶”ì¶œ ë¶ˆê°€
          format: format === 'json' ? 'json' : 'markdown',
          filePath: join(REPORTS_DIR, file),
        });
      }
    }

    // ìµœì‹ ìˆœ ì •ë ¬
    reports.sort((a, b) => b.createdAt.localeCompare(a.createdAt));

    // ì œí•œ
    if (options?.limit) {
      return reports.slice(0, options.limit);
    }

    return reports;
  } catch {
    return [];
  }
}

/**
 * ë¦¬í¬íŠ¸ ì¡°íšŒ
 */
export async function getReport(
  projectPath: string,
  reportId: string
): Promise<{ metadata: ReportMetadata; content: string } | null> {
  const reports = await listReports(projectPath);
  const metadata = reports.find((r) => r.id === reportId);

  if (!metadata) {
    return null;
  }

  try {
    const content = await readFile(join(projectPath, metadata.filePath), 'utf-8');
    return { metadata, content };
  } catch {
    return null;
  }
}

/**
 * ì£¼ê°„ ìš”ì•½ ë¦¬í¬íŠ¸ ìƒì„±
 */
export async function generateWeeklySummary(
  projectPath: string
): Promise<{ success: boolean; path?: string }> {
  const reports = await listReports(projectPath);

  // ìµœê·¼ 7ì¼ê°„ ë¦¬í¬íŠ¸ í•„í„°ë§
  const weekAgo = new Date();
  weekAgo.setDate(weekAgo.getDate() - 7);

  const weeklyReports = reports.filter((r) => {
    const reportDate = new Date(r.createdAt.replace(/-/g, ':'));
    return reportDate >= weekAgo;
  });

  if (weeklyReports.length === 0) {
    return { success: false };
  }

  // í†µê³„ ê³„ì‚°
  const stats = {
    totalRuns: weeklyReports.length,
    byTask: {} as Record<string, number>,
    totalIssuesFound: 0,
    totalIssuesFixed: 0,
  };

  for (const report of weeklyReports) {
    stats.byTask[report.taskType] = (stats.byTask[report.taskType] || 0) + 1;

    // JSON ë¦¬í¬íŠ¸ì—ì„œ ìƒì„¸ í†µê³„ ì¶”ì¶œ
    if (report.format === 'json') {
      try {
        const content = await readFile(join(projectPath, report.filePath), 'utf-8');
        const data = JSON.parse(content) as PostTaskResult;

        for (const result of data.results) {
          stats.totalIssuesFound += result.issuesFound;
          stats.totalIssuesFixed += result.issuesFixed;
        }
      } catch {
        // ë¬´ì‹œ
      }
    }
  }

  // ì£¼ê°„ ìš”ì•½ ìƒì„±
  const weekNumber = getWeekNumber(new Date());
  const lines: string[] = [];

  lines.push(`# Weekly Summary - Week ${weekNumber}`);
  lines.push('');
  lines.push(`**Period:** ${weekAgo.toISOString().split('T')[0]} - ${new Date().toISOString().split('T')[0]}`);
  lines.push('');

  lines.push('## Overview');
  lines.push('');
  lines.push(`| Metric | Value |`);
  lines.push(`|--------|-------|`);
  lines.push(`| Total Runs | ${stats.totalRuns} |`);
  lines.push(`| Issues Found | ${stats.totalIssuesFound} |`);
  lines.push(`| Issues Fixed | ${stats.totalIssuesFixed} |`);
  lines.push(`| Fix Rate | ${stats.totalIssuesFound > 0 ? Math.round((stats.totalIssuesFixed / stats.totalIssuesFound) * 100) : 0}% |`);
  lines.push('');

  lines.push('## By Task Type');
  lines.push('');
  lines.push(`| Task | Runs |`);
  lines.push(`|------|------|`);

  for (const [task, count] of Object.entries(stats.byTask).sort((a, b) => b[1] - a[1])) {
    lines.push(`| ${task} | ${count} |`);
  }

  lines.push('');
  lines.push('---');
  lines.push('');
  lines.push(`*Generated by ZyFlow Post-Task Agent*`);

  // ì €ì¥
  const summaryDir = join(projectPath, '.zyflow/reports/summary');
  await mkdir(summaryDir, { recursive: true });

  const filename = `weekly-${new Date().getFullYear()}-W${weekNumber}.md`;
  const filepath = join(summaryDir, filename);

  await writeFile(filepath, lines.join('\n'), 'utf-8');

  return {
    success: true,
    path: filepath.replace(projectPath + '/', ''),
  };
}

/**
 * ISO ì£¼ì°¨ ê³„ì‚°
 */
function getWeekNumber(date: Date): number {
  const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
  const dayNum = d.getUTCDay() || 7;
  d.setUTCDate(d.getUTCDate() + 4 - dayNum);
  const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
  return Math.ceil(((d.getTime() - yearStart.getTime()) / 86400000 + 1) / 7);
}
